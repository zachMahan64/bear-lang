HIR DESIGN DOC
--------------

===============
|     key     |
--------------- 
':' composed of
'|' or 
'->' mapped to
'[]' sliceof
'()' descript.
lowercase = 
    name
capitalized =
    HirType
===============

HIR STRUCTURES
--------------
- Declarations will define Hir nodes tied to scoped SymbolId tables and HirIdentifers will be the paths locating those definied nodes.
- Usages of any identifiers will explore those paths to ensure the existence of any mentioned identifiers by walking the scope tree and 
  then storing the HirId's at those the referenced Strings inside an HirIdentifier.
- Declarations must check their local scope to ensure no redefinitions occur.
   - hash look-up -> SymbolId representing the name (unscoped newly bound identifier) -> Map of the local HirScope pointing to the DefId
     of the newly declared node

CONTAINERS
-------------------------------------------------------------------------
VECTOR TABLES (used like arenas, but memory is pointed to by ids/indices)
*persisent, must be serializable
=========================================================================
note: the *IdIdx are necessary for contiguous slices of *Id's!

HirSymbolIdIdx -> HirSymbolId
HirSymbolId -> HirSymbol
HirSpanId -> Span

*block scopes should not be saved/stored

(persisent, serializable)
HirScopeId->
    HirScope:
        parent: HirScopeId?
        ScopeTable:
            modules: SymbolId -> HirDefId     (namespace/module names/static struct members)
            values:  SymbolId -> HirDefId     (variables, functions)
            types:   SymbolId -> HirDefId     (structs, unions, deftypes, variants)

(temporary, not serialized)
HirScopeAnonId->
    HirScopeAnon:
        parent: HirScopeId
        anon_parent: HirScopeAnonId?
        table: ScopeTable
            
HirExecIdIdx-> HirExecId
HirExecId -> HirExec

HirDefIdIdx -> HirDefId
HirDefId -> HirDef

HirTypeIdIdx -> HirTypeId
HirTypeId -> HirType

HirParamIdIdx -> HirParamId 
HirParamId -> HirParam 

HirGenericParamIdIdx -> HirGenericParamId 
HirGenericParamId -> HirGenericParam 

HirGenericArgIdIdx -> HirGenericArgId 
HirGenericArgId -> HirGenericArg

HASH TABLES
*temporary, not serialized
========================================
StringToSymbolTable: String â†’ HirSymbolId

--------------------------------------------------------------------------

HirIdentifier (used in type, expr, and module references; eg: std..println):
    segments:
        start: HirSymbolIdIdx
        len: uint32_t
    spans:
        start: HirSpanId
        len: uint32_t 
    resolved: DefId? (non-optional after resolution)

HirExecId -> HirExec:
    span: Span
    | HirStatement:
        | HirBlockStmt:
            HirBody:
                locals: HirScopeAnonId
                execs: []HirExecId
        | HirExprStmt:
            HirExecId -> HirExpr
        | HirEmptyStmt:
            ()
        | HirBreakStmt:
            HirExecId? -> HirExpr
        | HirIfStmt:
            condition: HirExecId -> HirExpr
            body: HirExecId -> HirBlockStmt
        | HirElseStmt:
            body: HirExecId -> HirBlockStmt
        | HirLoopStmt:
            body: HirExecId -> HirBlockStmt
        | HirReturnStmt:
            HirExecId? -> HirExpr
        | HirYieldStmt:
            HirExecId? -> HirExpr
    | HirExpr:
        TODO

(these are specifically type mentions, not definitions)
HirTypeId->
    HirType:
        span: Span
        | HirTypeBuiltin
        | HirTypeStructure:
            HirIdentifier
            resolved: HirDefId? (non-optional after resolution)
        | HirGenericStructure:
            HirTypeId
            []HirGenericArg
        | HirTypeArr:
            size: size_t? (non-optional after resolution)
            inner: HirTypeId
        | HirTypeRef:
            inner: HirTypeId
        | HirTypeFnPtr:
            []HirTypeId
            return_type: HirTypeId
        | HirTypeVariadic
            inner: HirTypeId



HirDefId ->
    span: Span
    HirDef:
        | HirFunctionDef:
            name: Span
            []HirParamId
            return_type: HirTypeId
            HirExecId? -> HirBody
            orig: HirDefId? -> HirGenericFunctionDef (if was originally generic and then was generated)
        | HirGenericFunctionDef:
            []HirGenericParam 
            HirFunctionDef
        | HirDestructorDef:
            HirFunctionDef
        | HirExternCFunctionDef:
            HirFunctionDef
        | HirVarDef:
            type: HirTypeId
            name: Span
        | HirModDef:
            scope: HirScopeId
            name: Span
        | HirStructDef
            scope: HirScopeId 
            name: Span
            contracts: []HirDefId -> HirContractDef
            orig: HirDefId? -> HirGenericStructDef (if was originally generic and then was generated)
        | HirGenericStructDef
            HirStructDef
           []HirGenericParam 
        | HirVariantDef
            scope: HirScopeId 
            name: Span
            orig: HirDefId? -> HirGenericVariantDef (if was originally generic and then was generated)
        | HirGenericVariantDef
            HirVariantDef
            []HirGenericParam
        | HirUnionDef
            scope: HirScopeId 
            name: Span 
        | HirContractDef
            scope: HirScopeId 
            name: Span 
        | HirDefTypeDef
            type: HirTypeId
            name: Span 

HirParam:
    def: HirDefId -> HirVarDef

HirGenericParam:
    | HirIdentifier (placeholder for types)
    | HirParam (placeholder for exprs)

HirGenericArg:
    | HirExecId -> HirExpr
    | HirTypeId

** note: generic defs will be stored as sugared and specifically instantiated as desugared defs that point to their orginal def
