HIR DESIGN DOC
--------------

===============
|     key     |
--------------- 
':' composed of
'|' or 
'->' mapped to
'[]' sliceof
'()' descript.
lowercase = 
    name
capitalized =
    HirType
===============

HIR STRUCTURES
--------------
- Declarations will define Hir nodes tied to scoped SymbolId tables and HirIdentifers will be the paths locating those definied nodes.
- Usages of any identifiers will explore those paths to ensure the existence of any mentioned identifiers by walking the scope tree and 
  then storing the HirId's at those the referenced Strings inside an HirIdentifier.
- Declarations must check their local scope to ensure no redefinitions occur.
   - hash look-up -> SymbolId representing the name (unscoped newly bound identifier) -> Map of the local HirScope pointing to the DefId
     of the newly declared node

CONTAINERS
-------------------------------------------------------------------------
VECTOR TABLES (used like arenas, but memory is pointed to by ids/indices)
*persisent, must be serializable
=========================================================================
note: the *IdIdx are necessary for contiguous slices of *Id's!

HirSymbolIdIdx -> HirSymbolId
HirSymbolId -> HirSymbol
HirSpanId -> Span

HirScopeId->
    HirScope:
        parent: HirScopeId?
        modules: SymbolId -> HirDefId     (namespace/module names/static struct members)
        values:  SymbolId -> HirDefId     (variables, functions)
        types:   SymbolId -> HirDefId    (structs, unions, deftypes, variants)

HirExecIdIdx-> HirExecId
HirExecId -> HirExec

HirDefIdIdx -> HirDefId
HirDefId -> HirDef

HirTypeId -> HirType

HirParamIdIdx -> HirParamId 
HirParamId -> HirParam 

HirGenericParamIdIdx -> HirGenericParamId 
HirGenericParamId -> HirGenericParam 

HirGenericArgIdIdx -> HirGenericArgId 
HirGenericArgId -> HirGenericArg

HASH TABLES
*persisent, must be serializable
========================================
StringToSymbolTable: String â†’ HirSymbolId

--------------------------------------------------------------------------

HirIdentifier (used in type, expr, and module references; eg: std..println):
    segments:
        start: HirSymbolIdIdx
        len: uint32_t
    spans:
        start: HirSpanId
        len: uint32_t 
    resolved: DefId?

HirExecId -> HirExec:
    | HirStatement:
        | HirBlockStmt:
            HirBody:
                []Hir
                []HirExecId
        | HirExprStmt:
            HirExecId -> HirExpr
        | HirEmptyStmt:
            ()
        | HirBreakStmt:
            HirExecId? -> HirExpr
        | HirIfStmt:
            condition: HirExecId -> HirExpr
            body: HirExecId -> HirBlockStmt
        | HirElseStmt:
            body: HirExecId -> HirBlockStmt
        | HirLoopStmt:
            body: HirExecId -> HirBlockStmt
        | HirReturnStmt:
            HirExecId? -> HirExpr
        | HirYieldStmt:
            HirExecId? -> HirExpr
    | HirExpr:
        TODO

(these are specifically type mentions, not definitions)
HirTypeId->
    HirType:
        | HirTypeBuiltin
        | HirDefId
        []HirGenericArg?

HirDefId ->
    HirDef:
        | HirFunctionDef:
            name: Span
            Params
            HirExecId? -> HirBody
            orig: HirDefId? -> HirGenericFunctionDef (if was originally generic and then was generated)
        | HirGenericFunctionDef:
            []HirGenericParam 
            HirFunctionDef
        | HirDestructorDef:
            HirFunctionDef
        | HirExternCFunctionDef:
            HirFunctionDef
        | HirVarDef:
            type: HirTypeId
            name: Span
        | HirModDef:
            scope: HirScopeId
            name: Span
        | HirStructDef
            scope: HirScopeId 
            name: Span
            contracts: []HirDefId -> HirContractDef
            orig: HirDefId? -> HirGenericStructDef (if was originally generic and then was generated)
        | HirGenericStructDef
            HirStructDef
           []HirGenericParam 
        | HirVariantDef
            scope: HirScopeId 
            name: Span
            orig: HirDefId? -> HirGenericVariantDef (if was originally generic and then was generated)
        | HirGenericVariantDef
            HirVariantDef
            []HirGenericParam
        | HirUnionDef
            scope: HirScopeId 
            name: Span 
        | HirContractDef
            scope: HirScopeId 
            name: Span 
        | HirDefTypeDef
            type: HirTypeId
            name: Span 

HirParam:
    HirId -> HirVarDef 

HirGenericParam:
    | HirIdentifier 

** note: generic defs will be stored as sugared and specifically instantiated as desugared defs that point to their orginal def
