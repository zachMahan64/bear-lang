fn foo(i32 x) -> i32 {
    return x * 2;
}

fn transform_i32(*fn(i32)->(i32) call, i32 x) -> i32 {
    return call(x);
}
compt *fn(i32)->(i32) funcy1;


static *fn(i32)->(i32) funcy2 = funcy1;

fn main() -> i32 {
    compt *fn(i32)->(i32) funcy3 = foo;
    [24] *fn(i32)->(i32) arr_of_funcs; // unsafe init, will be an error during later semantic passes

    var foobar = |var x|{do_work();};
    
    // immediate invocation
    i32 arg_val = 32;
    var closey = |var p|{return do_work_and_get_result(p);}(32);

    compt i32 FACTOR = 2;
    var closey_v2 = move |var x| {return arg_val * FACTOR;};
    
    return closey_v2(4);
}
